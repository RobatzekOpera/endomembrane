//***************************************************
// File: simpleSpot.script
//
// A simple stripped down attempt at spot detection for use in comparison over spot detection procedures.
// The aim is to first detect the maximum number of possible spots first, and then weed out problematic spots.
// Also a means of learning how to program a useful procedure using Acapella


//Input and image projection copied from endomembrane.script. It could be instructive to use procedures from OperaTemplates instead.
input(StackNo, 0, "Stack No", "i", "Number of the stacks to analyze. If set to 0 all stacks are evaluated.")
input(NumberOfChannels, 1, "Number Of Channels", "i", "Number of channels per field")
input(ZplanesInStack,21,"Zplanes in stack","i","Number of z-planes in stack, a number of time moments in kinetic measurement")
input(MinStdDev,4,"MinStdDev","i","Minimum standard deviation of pixel intensity in image.")

// READS IN IMAGES
Singlewell(compact=yes)


// COUNTS FIELDS AND CONTROLS IF ALL IMAGES ARE PRESENT
RobatzekProcs::ControlImageFieldsStackAC2(sourceData, NumberOfChannels, ZplanesInStack, StackNo)

// LOOP OVER IMAGE FIELDS
if(StackNo > 0)
	set(StartStack = StackNo, EndStack = StackNo)
end()
Foreach(StartStack .. EndStack, "_StackCounter") 
	
	RobatzekProcs::Assign_FirstLastZplane()	
	set(imagefilename1 = SourceData.sourcefilename[0])
	RobatzekProcs::CreateDataCubeWithControl()	
	RobatzekProcs::DataCubeProjectionCorrection()

	//Projects maximum intensity for each x-y position from datacube to image
	rearrange(datacube,vec(vec(0,0,1),vec(1,0,0),vec(0,1,0)), vec(datacube.depth, datacube.width,datacube.height), reduce="max")
		
	delete(datacube) 
	set(IM_projected=result)

//*****************************************//
// MY SPOT DETECTION METHOD  //
//*****************************************//
	set(image = IM_projected)
	//Is this needed?
	//AntiMedian(image=IM_projected)

	//create a mask from high intensity areas specified by a the calculated threshold. Subject to tuning
	ThresholdXX(0.4)
	Mask()

	//Turn the mask into a stencil and objectlist.
	Mask2Stencil(Neighbourhood=4)
	Stencil2Objects(|spots=objects)

	//Calculate the area of each object
	CalcArea(objects=spots | spots = objects)

	//Find inter-quartile range
	Quantile(spots.area, 0.5 |spotsareaQ1 = quantile)
	Quantile(spots.area, 0.75 |spotsareaQ2 = quantile)
	set(interquartilerange = spotsareaQ2 - spotsareaQ1)

	//delete any outlying areas
	set(lowerlimit = spotsareaQ1 - 3*interquartilerange)
	
	set(higherlimit = spotsareaQ2 + 3*interquartilerange)
	ObjectFilter(area < higherlimit, objects = spots | filteredSpots = objects)
	
	imageview(spots.body, "Spots", image = IM_projected)

	push(spotsvector, spots)
end()